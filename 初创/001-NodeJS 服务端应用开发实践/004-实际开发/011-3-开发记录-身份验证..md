# 身份验证

[toc]

## 1. 验证身份

- 服务端有时候需要知道是谁在访问它
- 在用户通过接口登录之后可以给用户签发一个令牌(token)
- JWT ~ JSON Web Token 是一种方式

## 2. 基于令牌的客户验证方法

- 浏览器 , 小程序等客户端都可以
- 在客户端通过接口登录
- 服务端在验证成功之后签发令牌
- 客户端收到令牌之后存储到本地
- 客户端之后的请求将令牌作为请求头的字段携带发送
- 服务端验证令牌数据 , 判断用户 , 判断有效性
- 服务端可以通说`JWT`签发和验证令牌

### 2.1 签发令牌时的加密方法

- 对称加密 Symmotric Encryption
  - 加密过程中设置密码
  - 知道密码就可以解密
  - **存在问题 :**
    - 需要验证用户的应用都会知道密码
    - 这些应用就都有了签发令牌的权限
- 非对称加密 Asymmotric Encryption
  - 存在秘钥(Private key)和公钥(Public Key)
  - 公钥基于密钥制造出来
  - 使用秘钥加密的数据可以使用**对应的**公钥解密
  - 使用公钥加密也可以使用**对应的**秘钥解密
  - **解决对称加密的问题:**
    - 可以让有签发令牌权限的应用使用密钥
    - 让其他需要验证但是签发权限的应用使用公钥验证令牌
    - 即使知道公钥也没法知道秘钥 , 也不能伪造令牌

## 2.2 秘钥与公钥的生成

- 在终端执行指令在根目录下生成秘钥文件

```zsh
cd ~/codes/xb2_node
mkdir config
cd config
openssl
> genrsa -out private.key 4096 # 创建一个 4096 为的秘钥文件 private.key
> rsa -in private.key -pubout -out public.key # 基于秘钥文件创建公钥文件
```

- 在`.gitignore`中通过`config/*.key` 忽略所有 `.key` 文件

## 2.3 准备秘钥与公钥的配置

- 可以将秘钥和公钥转换为放在环境变量中
- 让应用直接访问环境变量中的秘钥和公钥
- 这种做法存在问题
  - 环境变量不支持多行
- 解决方法
  - 将密钥和公钥转换为 base64 格式数据
  - 在应用中转换为原来的样子
  - 可以单独写一个转换秘钥公钥的程序 , 将转换结果输出到终端
  - 直接复制到环境变量中使用

```js
/* 
config/convert.key.js
*/

const fs = require('fs'); // nodeJS 中的文件系统
const path = require("path"); // 用于路径操作

/**
 * 读物公秘钥文件
 */
const privateKey = fs.readFileSync(path.join("config", "private.key"))
const publicKey = fs.readFileSync(path.join("config", "public.key"))

/**
 * 转换秘钥文件
 */

const privateKeyBase64 = Buffer.from(privateKey).toString("base64");
const publicKeyBase64 = Buffer.from(publicKey).toString("base64");

/**
 * 输出准换结果
 */
console.log("\n private Key");
console.log(privateKeyBase64);
console.log("\n public Key");
console.log(publicKeyBase64);
```

- 确认执行目录是在**根目录**中 并 执行转换程序

```zsh
cd ../
node convert.key.js
```

- 将准换结果添加到`.env`配置文件中

```env
PRIVATE_KEY=复制的秘钥值
PUBLIC_KEY=复制的公钥值
```

- 在`app.config`中将公秘钥结构出来并解码 , 将解码的结果导出

```js
/*
src/app/app.config.ts
*/
/**
 * 将公秘钥结构并解码
*/
let {PRIVATE_KEY,PUBLIC_KEY} = process.env;
// 解码
PRIVATE_KEY = Buffer.from(PRIVATE_KEY , "base64").toString()
PUBLIC_KEY = Buffer.from(PUBLIC_KEY , "base64").toString()
export {PRIVATE_KEY , PUBLIC_KEY}
```

## 3. 签发令牌

- 使用 JWT 形式的令牌 , 分为三个部分 `header , payload , Signature`
  - `Header` 头部 : 存放令牌的加密算法 , 类型等
  - `PayLoad` 数据 : 令牌的签发时间与有效期等 , 还可以携带自定义数据
  - `Signature`签名 : 根据 Header 和 Payload 根据特别的加密算法生成 , 用于防止伪造签名
- jsonwebtoken 包可以签发和验证 JWT 令牌

```zsh
npm install jsonwebtoken
npm install @types/jsonwebtoken --save-dev
```

## 定义令牌签发服务

```js
/*
src/auth/auth.service.ts
*/
import { PRIVATE_KEY} from "../app/app.config";
import jwt from "jsonwebtoken"

/**
 * 签发令牌
 */

// 定义配置参数
interface SignTokenOptions {
    payload? : any;
}

export const signToken = (options:SignTokenOptions) => {
    // 准备选项
    const {payload} = options;

    // 签发 token
    /**
     * sign 的参数
     * @param payload 令牌的 payload
     * @param PRIVATE_KEY 令牌生成的秘钥
     * @param {algorithm : 'RS256'} 令牌的加密算法
     */
    const token = jwt.sign(payload , PRIVATE_KEY , {algorithm : 'RS256'})

    // 返回 token
    return token;
}
```
